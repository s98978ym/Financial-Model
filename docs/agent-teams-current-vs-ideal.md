# Agent Teams: 現体制 vs 理想体制

## 1. 現体制の全体像

### 1.1 アーキテクチャ概要

```
┌─────────────────────────────────────────────────────────────────┐
│                    人間 (Yasunori)                               │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌───────────────┐   │
│  │ PR Review │  │ 本番確認  │  │ Hotfix   │  │ アーキ判断     │   │
│  └─────┬────┘  └─────┬────┘  └─────┬────┘  └──────┬────────┘   │
│        │             │             │               │            │
│========│=============│=============│===============│============│
│        ▼             ▼             ▼               ▼            │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │              Claude Code (単一セッション)                  │    │
│  │                                                         │    │
│  │  ┌─────────────────────────────────────────────────┐    │    │
│  │  │ 1つのAgentが全領域を担当                          │    │    │
│  │  │                                                 │    │    │
│  │  │  Backend + Frontend + Deployment + Worker        │    │    │
│  │  │  + DB + Docker + テスト + コードレビュー           │    │    │
│  │  └─────────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                 │
│  例外: 1回だけ Agent Teams パターンを使用 (bb50296)              │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐          │
│  │ Backend  │ │ Frontend │ │ Deploy   │ │ Worker   │          │
│  │ Team     │ │ Team     │ │ Team     │ │ Team     │          │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘          │
│  → 4並列で7問題を同時発見・修正 (最も効率的だったエピソード)       │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 現体制の構成要素

| 要素 | 状態 | 詳細 |
|------|------|------|
| **Claude Code セッション** | 1つ (稀に2並列) | session `LjpE` が65時間稼働で31コミット |
| **CLAUDE.md** | 存在しない | チーム定義・ルール・コンテキストなし |
| **Agent Teams 設定** | なし | ad-hocで1回だけ使用 |
| **CI/CD** | なし | テスト自動実行なし、手動デプロイ |
| **プロダクションAgent (Phase 1-5)** | 4つの専門Agent | BusinessModelAnalyzer, TemplateMapper, ModelDesigner, ParameterExtractor |
| **開発プロセスAgent** | なし | 開発・デプロイ・テストのAgent未定義 |

### 1.3 現体制のワークフロー

```
人間「Phase 3のボタンが動かない」
        │
        ▼
Claude (単一セッション) が調査→修正→コミット→プッシュ
        │
        ▼
人間がPRレビュー→マージ
        │
        ▼
本番デプロイ (手動)
        │
        ▼
人間が動作確認→追加バグ発見→再度Claudeに依頼 or 自分で修正
```

**問題点**:
- Claude と人間の間に **非同期ギャップ** がある (Claude実装→人間確認まで数時間)
- Claude はローカルでしか検証できない → **本番環境のバグを事前に防げない**
- 1つのセッションが全領域を担当 → **認知負荷が高く、アーキ判断ミスの温床**

### 1.4 現体制の数値的証拠

| 指標 | 値 | 意味 |
|------|-----|------|
| 3日間の総fixコミット | 33件 | 多すぎる。品質ゲートがない |
| 1-2コミットで解決 | 12件 (36%) | 成功率が低い |
| 3+コミットの手戻り | 21件 (64%) | **3分の2が手戻り** |
| 完全撤回 (無駄) | 7件 (21%) | proxy問題、まるごと廃棄 |
| Agent Teams使用回数 | 1回 | 唯一最も効率的だった |

---

## 2. 理想体制

### 2.1 全体アーキテクチャ

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         ORCHESTRATOR AGENT                              │
│              (タスク分析・チーム編成・統合・品質ゲート)                      │
│                                                                         │
│  入力: Issue / ユーザー指示 / エラーログ / デプロイ結果                     │
│  出力: 完了済みPR (テスト済み、レビュー済み、デプロイ可能)                   │
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                    PHASE 0: 事前分析                               │  │
│  │                                                                   │  │
│  │  ┌──────────────────┐  ┌──────────────────┐                      │  │
│  │  │ Architect Agent  │  │ Schema Agent     │                      │  │
│  │  │                  │  │                  │                      │  │
│  │  │ - アプローチ選択   │  │ - DB/API仕様確認  │                      │  │
│  │  │ - 代替案列挙      │  │ - FK/型の検証     │                      │  │
│  │  │ - リスク評価      │  │ - 環境変数確認    │                      │  │
│  │  │ - 影響範囲特定    │  │ - Docker構成確認  │                      │  │
│  │  └──────────────────┘  └──────────────────┘                      │  │
│  │                                                                   │  │
│  │  出力: 実装計画 (approach + 影響ファイル + リスク + 検証方法)         │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                              │                                          │
│                              ▼                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                    PHASE 1: 並列実装                               │  │
│  │                                                                   │  │
│  │  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐              │  │
│  │  │ Backend      │ │ Frontend     │ │ Infra        │              │  │
│  │  │ Agent        │ │ Agent        │ │ Agent        │              │  │
│  │  │              │ │              │ │              │              │  │
│  │  │ Python/      │ │ TypeScript/  │ │ Dockerfile/  │              │  │
│  │  │ FastAPI/     │ │ React/Next/  │ │ render.yaml/ │              │  │
│  │  │ Celery       │ │ TanStack     │ │ vercel.json  │              │  │
│  │  └──────────────┘ └──────────────┘ └──────────────┘              │  │
│  │                                                                   │  │
│  │  各Agentは自分の領域のみ変更。他領域へのインターフェースは            │  │
│  │  Architect Agentの計画に従う                                       │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                              │                                          │
│                              ▼                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                    PHASE 2: 検証                                   │  │
│  │                                                                   │  │
│  │  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐              │  │
│  │  │ Test Agent   │ │ Build Agent  │ │ Review Agent │              │  │
│  │  │              │ │              │ │              │              │  │
│  │  │ pytest 実行   │ │ Docker build │ │ コード品質    │              │  │
│  │  │ E2E テスト    │ │ Next.js build│ │ セキュリティ  │              │  │
│  │  │ 型チェック     │ │ 依存整合性   │ │ パターン一貫性 │              │  │
│  │  └──────────────┘ └──────────────┘ └──────────────┘              │  │
│  │                                                                   │  │
│  │  検証失敗 → PHASE 1 に差し戻し (具体的な修正指示付き)               │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                              │                                          │
│                              ▼                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                    PHASE 3: 統合 & デプロイ                        │  │
│  │                                                                   │  │
│  │  ┌──────────────────────────────────────────┐                     │  │
│  │  │ Orchestrator がコミット統合 → PR作成      │                     │  │
│  │  │ → 人間承認 → マージ → デプロイ確認         │                     │  │
│  │  └──────────────────────────────────────────┘                     │  │
│  └───────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 各Agentの役割定義

#### Tier 1: ゲートキーパー (実装前に必ず通る)

| Agent | 役割 | 入力 | 出力 | 発動条件 |
|-------|------|------|------|---------|
| **Orchestrator** | タスク分解・チーム編成・統合判断 | Issue/指示 | 実装計画・チーム割当 | 全タスク開始時 |
| **Architect** | アプローチの妥当性判断 | 実装計画 | 承認 or 代替案 | 新機能・バグ修正開始時 |
| **Schema** | DB/API/型の事前検証 | 変更対象のテーブル/エンドポイント | 制約一覧・正しいFK先・型情報 | DB関連変更時 |

**CORS/Proxy問題への適用シミュレーション**:
```
現実 (現体制):
  Claude「CORSエラーだ → Proxyを作ろう」→ 7コミット → 全撤回

理想 (Architect Agent介在):
  Architect「CORS_ORIGINSにpl-generator.vercel.appは登録済み？」
    → Schema Agent「yes、services/api/app/main.py の allow_origins に存在」
      → Architect「Proxyは不要。直接CORS接続をまず検証せよ」
        → 0コミットの無駄
```

#### Tier 2: 実装 (並列実行可能)

| Agent | 責任範囲 | 対象ファイル |
|-------|---------|------------|
| **Backend Agent** | Python, FastAPI, Celery tasks, DB queries | `services/api/`, `services/worker/`, `core/` |
| **Frontend Agent** | TypeScript, React, Next.js, TanStack Query | `apps/web/` |
| **Infra Agent** | Dockerfile, render.yaml, vercel.json, docker-compose | `infra/`, ルート設定ファイル |

**result_ref FK問題への適用シミュレーション**:
```
現実 (現体制):
  人間「result_refエラーだ」→ run_idに変更 (4コミット) → 間違い → phase_results.idに変更 (4コミット)

理想 (Schema Agent + Backend Agent):
  Schema Agent「jobs.result_ref は phase_results(id) を参照するFK」
    → Backend Agent「phase2-5の4ファイルを一括修正」
      → 1コミットで完了
```

#### Tier 3: 検証 (実装後に必ず通る)

| Agent | 検証内容 | ツール |
|-------|---------|--------|
| **Test Agent** | pytest, TypeScript型チェック, E2E | `pytest`, `tsc --noEmit`, playwright |
| **Build Agent** | Docker build, Next.js build, 依存関係整合性 | `docker build`, `npm run build` |
| **Review Agent** | コード品質、セキュリティ、パターン一貫性 | 静的解析、横断パターン検出 |

**Worker fallback問題への適用シミュレーション**:
```
現実 (現体制):
  Claude「sync fallback実装した」→ 人間が本番で動かないことを発見 → 3コミット追加修正

理想 (Build Agent + Test Agent):
  Build Agent「docker build → services/worker/tasks/ がCOPYされていない → 失敗」
    → 修正 → 再ビルド → 成功
  Test Agent「phase2.run_bm_analysis() → model_dump() AttributeError → Pydantic v2対応必要」
    → 修正 → 再テスト → 成功
  → 人間がデプロイ時にはバグゼロ
```

### 2.3 ワークフロー比較

#### 現体制のフロー

```
Issue発生 → Claude単独で調査・実装・コミット
                    │
              (数時間後)
                    │
              人間がPRレビュー → 本番デプロイ → バグ発見 → 再修正
                                                           │
                                                     (繰り返し)
```

**平均サイクルタイム: 3-5コミット/バグ、6-12時間/バグ**

#### 理想体制のフロー

```
Issue発生
    │
    ▼
Orchestrator: タスク分析 → チーム編成
    │
    ├── Architect: アプローチ承認 (5分)
    ├── Schema: DB/API制約確認 (3分)
    │
    ▼ (並列実行)
    ├── Backend Agent: Python実装
    ├── Frontend Agent: TypeScript実装
    ├── Infra Agent: 設定変更
    │
    ▼ (並列検証)
    ├── Test Agent: テスト実行
    ├── Build Agent: ビルド検証
    ├── Review Agent: コードレビュー
    │
    ▼
Orchestrator: 統合コミット → PR作成
    │
    ▼
人間: 承認 → マージ → デプロイ → 動く
```

**目標サイクルタイム: 1-2コミット/バグ、1-2時間/バグ**

---

## 3. 現体制から理想体制へのギャップ

### 3.1 ギャップ一覧

| # | 現状 | 理想 | ギャップ | 優先度 |
|---|------|------|---------|--------|
| 1 | CLAUDE.md なし | チームルール・コンテキスト定義済み | **P0** — これがないと全Agentがコンテキストレス | 最高 |
| 2 | CI/CD なし | テスト・ビルド自動実行 | **P0** — 検証Agentの基盤 | 最高 |
| 3 | Agent Teams 設定なし | Orchestrator + 6専門Agent | **P1** — 段階的に導入可能 | 高 |
| 4 | 単一セッション運用 | マルチセッション並列運用 | **P1** — CLAUDE.md で制御 | 高 |
| 5 | 手動デプロイ | デプロイ後の自動ヘルスチェック | **P2** — Render/Vercel webhook | 中 |
| 6 | エラーログ手動確認 | ログ→Issue→Agent自動起動 | **P3** — 将来の自動化 | 低 |

### 3.2 段階的導入ロードマップ

#### Phase 1: 基盤整備 (即座に実施可能)

```
1. CLAUDE.md を作成
   - プロジェクト構造の説明
   - DB スキーマの要約 (FK関係)
   - デプロイ構成 (Render API + Worker, Vercel Frontend)
   - コーディング規約 (Pydantic v2, model_dump()使用)
   - 「Proxyは使わない。直接CORSを使う」等の設計判断記録

2. テストスイートの整備
   - pytest: 既存32テスト → Phase 2-5の結合テスト追加
   - tsc --noEmit: TypeScript型チェック
   - docker build: Dockerfile の COPY 漏れ検出
```

#### Phase 2: Architect + Schema Agent 導入

```
全てのバグ修正・新機能の前に:

1. Architect Agent が実装計画を策定
   - 「何を変更するか」「なぜこのアプローチか」「代替案は？」
   - CLAUDE.md の設計判断記録を参照

2. Schema Agent がDB/API制約を確認
   - init.sql を読み、FK/CHECK/UNIQUE制約を列挙
   - 変更対象のテーブルの正しいリレーションを明示
```

#### Phase 3: 実装Agent分離 + 検証Agent導入

```
1. Backend / Frontend / Infra の3 Agent に分離
   - 各自のファイルスコープを限定
   - インターフェース (API契約) は Architect が定義

2. Test Agent + Build Agent を検証ゲートとして配置
   - PR作成前に必ず通過
   - 失敗時は具体的修正指示を返す
```

#### Phase 4: Orchestrator による完全自動化

```
1. Orchestrator がIssueからPRまでを一気通貫で管理
2. 人間の役割は「PRの承認」と「デプロイ確認」のみ
3. エラーログからの自動Issue起票 → Agent自動起動
```

---

## 4. 定量的改善予測

### 直近3日間のバグを理想体制で処理した場合のシミュレーション

| バグ | 現実 (コミット数) | 理想 (コミット数) | 削減率 | 理由 |
|------|-----------------|-----------------|--------|------|
| CORS/Proxy | 8 (7+撤回) | 1 | **87%** | Architectが「Proxy不要」と判断 |
| OOM | 3 | 2 | 33% | 元々効率的。Build Agentで若干改善 |
| Celery/Worker | 5 | 2 | **60%** | Build Agentがdocker build検証、Test AgentがPydantic検出 |
| result_ref FK | 8 | 1 | **87%** | Schema Agentが正しいFK先を特定、一括修正 |
| Phase 3ボタン | 1 | 1 | 0% | 元々最良パターン |
| Phase 2-5 Worker | 2 | 1 | 50% | 横断修正は既に効率的。Review Agentで統合 |
| Vercel設定 | 1 | 0 | **100%** | Build Agentが事前に検出 |
| **合計** | **28** | **8** | **71%** | |

### 推定改善効果

| 指標 | 現体制 | 理想体制 | 改善 |
|------|--------|---------|------|
| コミット/バグ (平均) | 4.0 | 1.1 | **-72%** |
| 完全撤回コミット | 21% | ~0% | **-100%** |
| 人間のhotfix負担 | 30コミット/3日 | ~5コミット/3日 | **-83%** |
| 本番デプロイ後のバグ発見 | 高頻度 | 低頻度 | CI/CDが事前検出 |

---

## 5. 結論

### 現体制の本質的問題

**「1つのAgentが全てを担当し、事前検証なしに実装→デプロイする」モデル。**

これは個人開発者が全部を手作業でやるのと本質的に同じであり、Agentの並列性・専門性という最大の強みを活かせていない。

### 理想体制の本質的価値

**「専門性の分離 + 事前ゲート + 並列実行 + 自動検証」の4層構造。**

唯一のAgent Teams成功例 (`bb50296`) が証明したように:
- 責任範囲を分離すれば、**各Agentはより深く正確に**問題を発見できる
- 独立した問題は**並列処理**で時間を短縮できる
- 事前のゲートキーパー (Architect/Schema) で**間違ったアプローチを防げる**
- 自動検証 (Test/Build) で**本番デプロイ前にバグを検出**できる

### 最も投資対効果が高い第一歩

1. **CLAUDE.md の作成** — 全Agentの共有コンテキスト (コスト: 30分、効果: 全体)
2. **CI/CD の導入** — `pytest` + `tsc --noEmit` + `docker build` (コスト: 2時間、効果: 検証自動化)
3. **Architect Agent の導入** — 実装前に「そもそも必要か？」を問う (コスト: ワークフロー変更のみ、効果: 撤回ゼロ化)
